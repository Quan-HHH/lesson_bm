<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </ul>
    <button id="btn"></button>
    <script>
        // 点击每一个li 输出li里面的内容

        // 1. 常规思维  
        // 缺点  只能选中当前页面已有的li节点 并给他们绑定事件 后添加的节点 没有效果
        // const lis = document.querySelectorAll('li');
        // lis.forEach((li) => {
        //     li.addEventListener('click', function() {
        //         console.log(li.innerText)
        //     })
        // })
        setTimeout(function() {
            const ul = document.querySelector('ul');
            const li = document.createElement('li')
            li.innerText = "4"
            ul.appendChild(li);
        }, 3000)

        // 2. 将监听事件 绑定到父级 ul上
        // 借助事件会冒泡的特点 父节点 也可以监听到 子节点有没有发生点击事件
        // 如果子节点点击了 父节点也会收到这个点击事件
        const ul = document.querySelector('ul');
        ul.addEventListener('click', function() {
            // 怎么输出li里的文本内容
            // li.innerText
            // console.log(event)
            const target = event.target;
            console.log(target.innerText)
        })
        // dom0标准 缺点： 会覆盖
        const btn = document.getElementById('btn');
        btn.onclick = function() {
            console.log(0)
        }
        btn.onclick = function() {
            console.log(1)
        }
        // dom2
        btn.addEventListener('click', () => {
            console.log(11)
        })
        // dom3 添加了鼠标 键盘事件
        btn.addEventListener('click', () => {
            console.log(12)
        })
    </script>
</body>
</html>